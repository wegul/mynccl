#include "debug_util.h"
#include "err.h"
#include <arpa/inet.h>
#include <atomic>
#include <chrono>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <fcntl.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <thread>
#include <unistd.h>
/* @brief: this function connects to the ctrl server, sends local handle,
 * and receives remote handle
 * @param local_handle: the local handle generated by listen(), to be sent
 * @param remote_handle: the remote handle received from ctrl server, to be used
 * in connect()
 * @return: 0 on success, -1 on failure
 */
const char *servAddr_str = "10.0.0.1";
const uint32_t servPort = 8888;
int connectToCtrlServerAndExchangeHandles(void *local_handle,
                                          void *remote_handle);

int main() {
  const ncclNet_t *plugin = &ncclNetPlugin_v10;
  std::cout << "Hello, World!" << std::endl;
  std::cout << plugin->name << std::endl;
  plugin->init(mock_logger, nullptr);
  ncclNetProperties_t *props =
      (ncclNetProperties_t *)calloc(1, sizeof(ncclNetProperties_t));
  plugin->getProperties(0, props);
  print_nccl_properties(props);
  plugin->getProperties(1, props);
  print_nccl_properties(props);

  void *lcomm = nullptr, *rcomm = nullptr, *scomm = nullptr;
  void *local_handle = calloc(1, NCCL_NET_HANDLE_MAXSIZE);
  void *remote_handle = calloc(1, NCCL_NET_HANDLE_MAXSIZE);
  plugin->listen(0, local_handle, &lcomm);
  /* build a connection to ctrlServer to send handle and receive remote
   * handles In this test case, we should send exactly one handle, and receive
   * exactly one handle.
   */
  connectToCtrlServerAndExchangeHandles(local_handle, remote_handle);

  // After getting remote_handle, start accept/connect.

  // After getting remote_handle, start accept/connect in separate threads
  std::atomic<bool> accept_done{false};
  std::atomic<bool> connect_done{false};

  // Thread for accept polling
  std::thread accept_thread([&]() {
    while (!accept_done.load()) {
      ncclResult_t result = plugin->accept(lcomm, &rcomm, nullptr);
      if (result != ncclSuccess) {
        ERR("Accept failed with error: " << result);
        break;
      }
      if (rcomm != nullptr) {
        INFO("Accept completed successfully");
        accept_done.store(true);
        break;
      }
      std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
  });

  // Thread for connect polling
  std::thread connect_thread([&]() {
    while (!connect_done.load()) {
      ncclResult_t result =
          plugin->connect(0, nullptr, remote_handle, &scomm, nullptr);
      if (result != ncclSuccess) {
        ERR("Connect failed with error: " << result);
        break;
      }
      if (rcomm != nullptr) {
        INFO("Connect completed successfully");
        connect_done.store(true);
        break;
      }
      std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
  });

  // Wait for both threads to complete
  accept_thread.join();
  connect_thread.join();

  if (accept_done.load() && connect_done.load()) {
    INFO("Both accept and connect completed successfully");
    INFO("rcomm: " << rcomm << ", scomm: " << scomm);
  } else {
    ERR("Failed to establish connections");
  }

  char msg[256], recvbuf[256];
  snprintf(msg, sizeof(msg), "Hello from mock GPU <%s>\n", props->name);
  memset(recvbuf, 0, sizeof(recvbuf));

  // Start non-blocking receive and send operations
  void *recv_request = nullptr, *send_request = nullptr;
  size_t recv_size = 256;
  int recv_tag = 0;
  std::atomic<bool> recv_done{false};

  // Create array of pointers - the API expects void** (array of void* pointers)
  void *recv_data_ptrs[] = {recvbuf}; // recvbuf decays to char* which

  // Thread for blocking receive operation
  std::thread recv_thread([&]() {
    INFO("Starting blocking receive in separate thread");
    ncclResult_t result =
        plugin->irecv(rcomm, 1, recv_data_ptrs, &recv_size, &recv_tag,
                      (void **)nullptr, (void **)nullptr, &recv_request);
    recv_done.store(true);
  });

  // Start non-blocking send operation in main thread
  plugin->isend(scomm, msg, 256, 0, nullptr, nullptr, &send_request);
  INFO("Started non-blocking send: " << msg);

  // Give some time for operations to complete
  std::this_thread::sleep_for(std::chrono::milliseconds(1000));

  // Wait for receive thread to complete
  recv_thread.join();

  // Check if receive was successful and display the result
  if (recv_done.load()) {
    INFO("Successfully received message: " << recvbuf);
  } else {
    ERR("Receive operation failed or did not complete");
  }

  // Clean up
  plugin->closeListen(lcomm);
  free(local_handle);
  free(remote_handle);
  free(props);
  return 0;
}

int connectToCtrlServerAndExchangeHandles(void *local_handle,
                                          void *remote_handle) {
  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0) {
    ERR("Error creating socket");
    return -1;
  }

  struct sockaddr_in serv_addr;
  memset(&serv_addr, 0, sizeof(serv_addr));
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = inet_addr(servAddr_str);
  serv_addr.sin_port = htons(servPort);

  if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
    ERR("Error connecting to control server at " << servAddr_str << ":"
                                                 << servPort);
    close(sockfd);
    return -1;
  }
  INFO("Connected to control server at " << servAddr_str << ":" << servPort);
  // Send local handle
  if (send(sockfd, local_handle, MAX_HANDLE_SZ, 0) < 0) {
    ERR("Error sending handle to control server");
    close(sockfd);
    return -1;
  }
  INFO("Sent local handle to control server");

  // Receive remote handle
  ssize_t bytes_received =
      recv(sockfd, remote_handle, MAX_HANDLE_SZ, MSG_WAITALL);
  if (bytes_received < 1) {
    ERR("Error receiving remote handle from control server");
    close(sockfd);
    return -1;
  }
  // close connection to ctrl server
  close(sockfd);
  INFO("Received remote handle from control server");
  return 0;
}