/*************************************************************************
 * Copyright (c) 2015-2024, NVIDIA CORPORATION. All rights reserved.
 *
 * See LICENSE.txt for license information
 ************************************************************************/

#include "BufPool.h"
#include "Endpoint.h"
#include "Request.h"
#include "common.h"
#include "config.h"
#include "err.h"
#include "net.h"
#include <arpa/inet.h>
#include <cassert>
#include <cstddef> // for size_t, NULL
#include <cstdint>
#include <cstdio>  // for snprintf
#include <cstdlib> // for realpath
#include <cstring> // for memcpy
#include <cuda_runtime.h>
#include <memory> // for std::shared_ptr, std::make_shared
#include <netdb.h>
#include <netinet/in.h>
#include <strings.h>
#include <sys/socket.h>
#include <thread>
#include <unistd.h>

using namespace gnic;

#define __hidden __attribute__((visibility("default")))
#define NCCL_PLUGIN_MAX_RECVS 1

std::shared_ptr<gnic::Endpoint> ep;
int max_requests = NCCL_NET_MAX_REQUESTS;
ncclDebugLogger_t logFunction = nullptr;
enum ConnState { kConnInit = 0, kConnConnecting, kConnConnected };

struct BaseComm {
  int dev;
  std::shared_ptr<ReqPool> reqPool;
};
struct AcceptState {
  int clientfd;
  struct BaseComm base;
  uint32_t clientAddr;
  int clientDev;
};
struct ListenComm {
  int sockfd;
  int gpuidx;
  enum ConnState state = kConnInit; // Connection state
  struct BaseComm base;             // local base
  struct AcceptState acceptBuf;
};
struct SendComm {
  int sockfd;
  struct BaseComm base;
};
struct RecvComm {
  int sockfd;
  struct BaseComm base;
};
// ConnHandle is generated by Listen(server) and transferred to Connect(client).
struct ConnHandle {
  struct BaseComm base;
  int sockfd;
  uint32_t serv_ip_addr_u32;
  uint16_t listen_port;
  int remote_dev;
  int remote_gpuidx; // Remote gpu index; acquired by cudaGetDevice.
  enum ConnState state = kConnInit;
};

__hidden ncclResult_t pluginInit(ncclDebugLogger_t logFunction,
                                 ncclProfilerCallback_t profFunction) {
  // Set the global logger function
  ::logFunction = logFunction;
  INFO(NCCL_NET, "myNCCL plugin initialized with PID: %d", getpid());
  ep = std::make_shared<gnic::Endpoint>();
  return ncclSuccess;
}
__hidden ncclResult_t pluginDevices(int *ndev) {
  *ndev = ep->getNumDevices();
  return ncclSuccess;
}

// __hidden ncclResult_t pluginPtrSupport(int dev, int *supportedTypes) { return
// ncclInternalError; }
/// @ref ncclIbGetPciPath
__hidden ncclResult_t pluginPciPath(char const *ib_name, char **path) {
  char devicePath[256];
  snprintf(devicePath, 256, "/sys/class/infiniband/%s/device", ib_name);
  char *p = realpath(devicePath, NULL);
  if (p == NULL) {
    ERROR("Could not find device path for %s", ib_name);
    return ncclInternalError;
  }
  *path = p;
  return ncclSuccess;
}
#define KNL_MODULE_LOADED(a) ((access(a, F_OK) == -1) ? 0 : 1)
static bool GdrSupportInitOnce() {
  // Check for the nv_peer_mem module being loaded
  return KNL_MODULE_LOADED("/sys/kernel/mm/memory_peers/nv_mem/version") ||
         KNL_MODULE_LOADED("/sys/kernel/mm/memory_peers/nv_mem_nc/version") ||
         KNL_MODULE_LOADED("/sys/module/nvidia_peermem/version");
}
__hidden ncclResult_t pluginGetProperties(int dev, ncclNetProperties_t *props) {
  // Below are default values, if unsure don't change.
  auto rnic_dev = ep->get_device(dev);
  props->name = rnic_dev->ib_name;
  // Fill for proper topology detection, e.g.
  // /sys/devices/pci0000:00/0000:00:10.0/0000:0b:00.0
  if (ncclSuccess != pluginPciPath(rnic_dev->ib_name, &props->pciPath)) {
    WARN("Failed to get PCI path for device %s", rnic_dev->ib_name);
  }
  // Only used to detect NICs with multiple PCI attachments.
  props->guid = rnic_dev->dev_attr.sys_image_guid;

  // Add NCCL_PTR_CUDA if GPU Direct RDMA is supported and regMr can take CUDA
  // pointers.
  props->ptrSupport = NCCL_PTR_HOST;
  if (GdrSupportInitOnce())
    props->ptrSupport |= NCCL_PTR_CUDA;
  if (rnic_dev->dmaBufSupported)
    props->ptrSupport |= NCCL_PTR_DMABUF;
  if (props->ptrSupport == NCCL_PTR_HOST) {
    WARN("Lack of GPU Direct RDMA support.");
  }

  // If you regMr has a fast registration cache, set to 1. If set to 0, user
  // buffer registration may be disabled.
  props->regIsGlobal = 0;
  // Force flush after receive. Needed if the control path and data path use a
  // different path to the GPU
  props->forceFlush = 0;

  // Speed in *Mbps*. 100000 means 100G
  props->speed = rnic_dev->link_bw;
  // Port number, used in conjunction with guid
  props->port = rnic_dev->portNum;
  // Custom latency (used to help tuning if latency is high. If set to 0, use
  // default NCCL values.
  props->latency = 0;
  // Maximum number of comm objects we can create.
  props->maxComms = 1024 * 1024;
  // Maximum number of receive operations taken by irecv().
  props->maxRecvs = NCCL_PLUGIN_MAX_RECVS;
  // Coupling with NCCL network device-side code.
  props->netDeviceType = NCCL_NET_DEVICE_HOST;
  props->netDeviceVersion = NCCL_NET_DEVICE_INVALID_VERSION;
  // Used to tell NCCL core whether this is a virtual device fusing multiple
  // physical devices.
  props->vProps.ndevs = 1;
  props->vProps.devs[0] = dev;

  // maximum transfer sizes the plugin can handle
  props->maxP2pBytes = NCCL_MAX_NET_SIZE_BYTES;
  props->maxCollBytes = NCCL_MAX_NET_SIZE_BYTES;
  return ncclSuccess;
}

__hidden ncclResult_t pluginListen(int dev, void *handle, void **listenComm) {
  struct ConnHandle *connHandle = (struct ConnHandle *)handle;
  memset(connHandle, 0, sizeof(struct ConnHandle));

  // Create a TCP listening socket (bootstrapping the RDMA connection)
  int listenSockFd = socket(AF_INET, SOCK_STREAM, 0);
  if (listenSockFd < 0) {
    ERROR("Failed to create socket: %s", strerror(errno));
    return ncclSystemError;
  }
  int flag = 1;
  setsockopt(listenSockFd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(int));
  sockaddr_in listenAddr;
  memset(&listenAddr, 0, sizeof(listenAddr));
  listenAddr.sin_family = AF_INET;
  listenAddr.sin_addr.s_addr =
      INADDR_ANY;          /******************************************
                            * TODO: Should bind to two IPs:
                            * 1. Main IP
                            * 2. Forwarding IP
                            * Instead of using INADDR_ANY
                            ******************************************/
  listenAddr.sin_port = 0; // Let the OS choose a free port

  if (bind(listenSockFd, (struct sockaddr *)&listenAddr, sizeof(listenAddr)) <
      0) {
    ERROR("Failed to bind socket: %s", strerror(errno));
    close(listenSockFd);
    return ncclSystemError;
  }

  // Get the actual port assigned by the OS.
  socklen_t len = sizeof(listenAddr);
  getsockname(listenSockFd, (struct sockaddr *)&listenAddr, &len);
  if (listen(listenSockFd, 1) != 0) {
    ERROR("Failed to listen on socket: %s", strerror(errno));
    close(listenSockFd);
    return ncclSystemError;
  }

  connHandle->serv_ip_addr_u32 = ntohl(listenAddr.sin_addr.s_addr);
  connHandle->listen_port = ntohs(listenAddr.sin_port);
  if (cudaGetDevice(&connHandle->remote_gpuidx) != cudaSuccess) {
    ERROR("cudaGetDevice failed");
    close(listenSockFd);
    return ncclSystemError;
  }

  struct ListenComm *lcomm =
      (struct ListenComm *)calloc(1, sizeof(struct ListenComm));

  lcomm->sockfd = listenSockFd;
  lcomm->base.dev = dev;
  lcomm->gpuidx = connHandle->remote_gpuidx;
  *listenComm = (void *)lcomm;

  INFO(NCCL_NET, "Listening on %s:%d (GPU index: %d), sockfd: %d",
       inet_ntoa(listenAddr.sin_addr), ntohs(listenAddr.sin_port),
       connHandle->remote_gpuidx, listenSockFd);

  return ncclSuccess;
}
// TODO: make it RDMA-capable. Currently this is a TCP connection. We reuse
// bootstrap socket to do data transfer for test purposes.
__hidden ncclResult_t pluginConnect(int dev, ncclNetCommConfig_t *config,
                                    void *handle, void **sendComm,
                                    ncclNetDeviceHandle_t **sendDevComm) {

  struct ConnHandle *connHandle = (struct ConnHandle *)handle;
  uint32_t remote_ip_u32 = connHandle->serv_ip_addr_u32;
  int local_gpuidx;
  if (cudaGetDevice(&local_gpuidx) != cudaSuccess) {
    ERROR("cudaGetDevice failed");
    return ncclSystemError;
  }
  struct SendComm *scomm =
      (struct SendComm *)calloc(1, sizeof(struct SendComm));

  if (connHandle->state == kConnInit) {
    connHandle->state = kConnConnecting;
    std::thread t = std::thread([dev, connHandle, local_gpuidx, remote_ip_u32] {
      connHandle->sockfd = ep->rdmaConnect(dev, local_gpuidx, remote_ip_u32,
                                           connHandle->listen_port);
      std::atomic_thread_fence(std::memory_order_release);
      connHandle->state = kConnConnected;
    });
    t.detach();
    free(scomm);
  } else if (connHandle->state == kConnConnecting) {
    *sendComm = NULL;
    free(scomm);
    return ncclSuccess;
  } else {
    // Already connected, just return the existing sendComm and initiate
    // bufpool.
    scomm->sockfd = connHandle->sockfd;
    scomm->base = connHandle->base;
    scomm->base.reqPool = std::make_shared<ReqPool>();
    *sendComm = (void *)scomm;
  }
  if (*sendComm) {
    INFO(NCCL_NET, "Connected to %s:%d (GPU index: %d)",
         inet_ntoa(*(struct in_addr *)&remote_ip_u32), connHandle->listen_port,
         connHandle->remote_gpuidx);
  }

  return ncclSuccess;
}
__hidden ncclResult_t pluginAccept(void *listenComm, void **recvComm,
                                   ncclNetDeviceHandle_t **recvDevComm) {
  struct ListenComm *lcomm = (struct ListenComm *)listenComm;
  struct RecvComm *rcomm =
      (struct RecvComm *)calloc(1, sizeof(struct RecvComm));

  if (lcomm->state == kConnInit) {
    lcomm->state = kConnConnecting;
    // Accept the connection from the client
    INFO(NCCL_NET, "Waiting to accept on dev %d", lcomm->base.dev);
    std::thread t = std::thread([lcomm] {
      uint32_t clientAddr;
      lcomm->acceptBuf.clientfd=ep->rdmaAccept(lcomm->sockfd, &clientAddr);
      lcomm->state = kConnConnected;
      std::atomic_thread_fence(std::memory_order_release);
    });
    t.detach();
    *recvComm = nullptr;
    free(rcomm);
  } else if (lcomm->state == kConnConnecting) {
    *recvComm = nullptr;
    free(rcomm);
  } else {
    rcomm->sockfd = lcomm->acceptBuf.clientfd;
    rcomm->base = lcomm->acceptBuf.base;
    rcomm->base.reqPool = std::make_shared<ReqPool>();
    *recvComm = rcomm;
  }
  if (*recvComm) {
    INFO(NCCL_NET, "Accepted connection from %s (GPU index: %d), sockfd: %d",
         inet_ntoa(*(struct in_addr *)&lcomm->acceptBuf.clientAddr),
         lcomm->acceptBuf.clientDev, rcomm->sockfd);
  }

  return ncclSuccess;
}
__hidden ncclResult_t pluginRegMr(void *collComm, void *data, size_t size,
                                  int type, void **mhandle) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginRegMrDmaBuf(void *collComm, void *data, size_t size,
                                        int type, uint64_t offset, int fd,
                                        void **mhandle) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginDeregMr(void *collComm, void *mhandle) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginIsend(void *sendComm, void *data, size_t size,
                                  int tag, void *mhandle, void *phandle,
                                  void **request) {
  struct SendComm *scomm = (struct SendComm *)sendComm;
  // struct Mhandle* mh= (struct Mhandle*)mhandle;
  // Allocate a request buffer from the request pool
  uint64_t addr;
  if (scomm->base.reqPool->alloc_buff(&addr)) {
    *request = nullptr;
    ERROR("Failed to allocate send request buffer");
    return ncclSuccess;
  }
  struct Request *req = reinterpret_cast<struct Request *>(addr);
  ep->asyncSend(scomm->sockfd, data, size, req);
  req->req_pool = (void *)scomm->base.reqPool.get();
  return ncclSuccess;
}
/**
 * @brief: In current TCP socket version, we can only let n=1 because
 * this means caller wish to receive data in data[0] with sizes[0].
 */
__hidden ncclResult_t pluginIrecv(void *recvComm, int n, void **data,
                                  size_t *sizes, int *tags, void **mhandles,
                                  void **phandles, void **request) {
  if (n != 1) {
    ERROR("n!=1!!!");
    return ncclInternalError;
  }
  struct RecvComm *rcomm = (struct RecvComm *)recvComm;
  uint64_t addr;
  if (rcomm->base.reqPool->alloc_buff(&addr)) {
    *request = nullptr;
    ERROR("Failed to allocate recv request buffer");
    return ncclSuccess;
  }

  struct Request *req = reinterpret_cast<struct Request *>(addr);
  ep->asyncRecv(rcomm->sockfd, data[0], sizes[0], req);
  req->req_pool = (void *)rcomm->base.reqPool.get();
  *request = (void *)req;

  return ncclSuccess;
}
__hidden ncclResult_t pluginIflush(void *recvComm, int n, void **data,
                                   int *sizes, void **mhandles,
                                   void **request) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginTest(void *request, int *done, int *size) {
  *done = 0;
  struct Request *r = (struct Request *)request;
  if (!r) {
    WARN("NET/Socket : test called with NULL request");
    return ncclInternalError;
  }

  return ncclInternalError;
}
__hidden ncclResult_t pluginCloseSend(void *sendComm) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginCloseRecv(void *recvComm) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginCloseListen(void *listenComm) {
  struct ListenComm *comm = (struct ListenComm *)listenComm;
  close(comm->sockfd);
  free(comm);
  return ncclSuccess;
}
__hidden ncclResult_t pluginIrecvConsumed(void *recvComm, int n,
                                          void *request) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginGetDeviceMr(void *comm, void *mhandle,
                                        void **dptr_mhandle) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginMakeVDevice(int *d, ncclNetVDeviceProps_t *props) {
  return ncclInternalError;
}

#define PLUGIN_NAME "swg-Plugin"
extern "C" {
extern const ncclNet_v10_t ncclNetPlugin_v10 = {
    .name = PLUGIN_NAME,
    .init = pluginInit,
    .devices = pluginDevices,
    .getProperties = pluginGetProperties,
    .listen = pluginListen,
    .connect = pluginConnect,
    .accept = pluginAccept,
    .regMr = pluginRegMr,
    .regMrDmaBuf = pluginRegMrDmaBuf,
    .deregMr = pluginDeregMr,
    .isend = pluginIsend,
    .irecv = pluginIrecv,
    .iflush = pluginIflush,
    .test = pluginTest,
    .closeSend = pluginCloseSend,
    .closeRecv = pluginCloseRecv,
    .closeListen = pluginCloseListen,
    .getDeviceMr = pluginGetDeviceMr,
    .irecvConsumed = pluginIrecvConsumed,
    .makeVDevice = pluginMakeVDevice,
};
}

__hidden ncclResult_t pluginInit_v9(ncclDebugLogger_t logFunction) {
  return pluginInit(logFunction, NULL);
}

__hidden ncclResult_t pluginGetProperties_v9(int dev,
                                             ncclNetProperties_v9_t *props) {
  return pluginGetProperties(dev, (ncclNetProperties_t *)props);
}

__hidden ncclResult_t pluginConnect_v9(int dev, void *handle, void **sendComm,
                                       ncclNetDeviceHandle_t **sendDevComm) {
  return pluginConnect(dev, NULL, handle, sendComm, sendDevComm);
}

__hidden ncclResult_t pluginIsend_v9(void *sendComm, void *data, size_t size,
                                     int tag, void *mhandle, void **request) {
  return pluginIsend(sendComm, data, size, tag, mhandle, NULL, request);
}

__hidden ncclResult_t pluginIrecv_v9(void *recvComm, int n, void **data,
                                     size_t *sizes, int *tags, void **mhandles,
                                     void **request) {
  return pluginIrecv(recvComm, n, data, sizes, tags, mhandles, NULL, request);
}

__hidden ncclResult_t pluginMakeVDevice_v9(int *d,
                                           ncclNetVDeviceProps_v9_t *props) {
  return ncclInternalError;
}

const ncclNet_v9_t ncclNetPlugin_v9 = {
    .name = PLUGIN_NAME,
    .init = pluginInit_v9,
    .devices = pluginDevices,
    .getProperties = pluginGetProperties_v9,
    .listen = pluginListen,
    .connect = pluginConnect_v9,
    .accept = pluginAccept,
    .regMr = pluginRegMr,
    .regMrDmaBuf = pluginRegMrDmaBuf,
    .deregMr = pluginDeregMr,
    .isend = pluginIsend_v9,
    .irecv = pluginIrecv_v9,
    .iflush = pluginIflush,
    .test = pluginTest,
    .closeSend = pluginCloseSend,
    .closeRecv = pluginCloseRecv,
    .closeListen = pluginCloseListen,
    .getDeviceMr = pluginGetDeviceMr,
    .irecvConsumed = pluginIrecvConsumed,
    .makeVDevice = pluginMakeVDevice_v9,
};

__hidden ncclResult_t pluginGetProperties_v8(int dev,
                                             ncclNetProperties_v8_t *props_v8) {
  ncclNetProperties_t props;
  ncclResult_t ret = pluginGetProperties(dev, &props);
  if (ret != ncclSuccess)
    return ret;
  props_v8->name = props.name;
  props_v8->pciPath = props.pciPath;
  props_v8->guid = props.guid;
  props_v8->ptrSupport = props.ptrSupport;
  props_v8->regIsGlobal = props.regIsGlobal;
  props_v8->speed = props.speed;
  props_v8->latency = props.latency;
  props_v8->port = props.port;
  props_v8->maxComms = props.maxComms;
  props_v8->maxRecvs = props.maxRecvs;
  props_v8->netDeviceType = props.netDeviceType;
  props_v8->netDeviceVersion = props.netDeviceVersion;
  return ncclSuccess;
}

__hidden ncclResult_t pluginIsend_v8(void *sendComm, void *data, int size,
                                     int tag, void *mhandle, void **request) {
  return pluginIsend(sendComm, data, (int)size, tag, mhandle, NULL, request);
}

__hidden ncclResult_t pluginIrecv_v8(void *recvComm, int n, void **data,
                                     int *sizes, int *tags, void **mhandles,
                                     void **request) {
  size_t sizesOut[NCCL_PLUGIN_MAX_RECVS];
  for (int i = 0; i < n; i++)
    sizesOut[i] = sizes[i];
  return pluginIrecv(recvComm, 1, data, sizesOut, tags, mhandles, NULL,
                     request);
}

const ncclNet_v8_t ncclNetPlugin_v8 = {
    .name = PLUGIN_NAME,
    .init = pluginInit_v9,
    .devices = pluginDevices,
    .getProperties = pluginGetProperties_v8,
    .listen = pluginListen,
    .connect = pluginConnect_v9,
    .accept = pluginAccept,
    .regMr = pluginRegMr,
    .regMrDmaBuf = pluginRegMrDmaBuf,
    .deregMr = pluginDeregMr,
    .isend = pluginIsend_v8,
    .irecv = pluginIrecv_v8,
    .iflush = pluginIflush,
    .test = pluginTest,
    .closeSend = pluginCloseSend,
    .closeRecv = pluginCloseRecv,
    .closeListen = pluginCloseListen,
    .getDeviceMr = pluginGetDeviceMr,
    .irecvConsumed = pluginIrecvConsumed,
};

__hidden ncclResult_t pluginGetProperties_v7(int dev,
                                             ncclNetProperties_v7_t *props_v7) {
  ncclNetProperties_t props;
  ncclResult_t ret = pluginGetProperties(dev, &props);
  if (ret != ncclSuccess)
    return ret;
  props_v7->name = props.name;
  props_v7->pciPath = props.pciPath;
  props_v7->guid = props.guid;
  props_v7->ptrSupport = props.ptrSupport;
  props_v7->speed = props.speed;
  props_v7->latency = props.latency;
  props_v7->port = props.port;
  props_v7->maxComms = props.maxComms;
  props_v7->maxRecvs = props.maxRecvs;
  props_v7->netDeviceType = props.netDeviceType;
  props_v7->netDeviceVersion = props.netDeviceVersion;
  return ncclSuccess;
}

__hidden ncclResult_t pluginRegMr_v7(void *collComm, void *data, int size,
                                     int type, void **mhandle) {
  return pluginRegMr(collComm, data, size, type, mhandle);
}

const ncclNet_v7_t ncclNetPlugin_v7 = {
    .name = PLUGIN_NAME,
    .init = pluginInit_v9,
    .devices = pluginDevices,
    .getProperties = pluginGetProperties_v7,
    .listen = pluginListen,
    .connect = pluginConnect_v9,
    .accept = pluginAccept,
    .regMr = pluginRegMr_v7,
    .regMrDmaBuf = pluginRegMrDmaBuf,
    .deregMr = pluginDeregMr,
    .isend = pluginIsend_v8,
    .irecv = pluginIrecv_v8,
    .iflush = pluginIflush,
    .test = pluginTest,
    .closeSend = pluginCloseSend,
    .closeRecv = pluginCloseRecv,
    .closeListen = pluginCloseListen,
    .getDeviceMr = pluginGetDeviceMr,
    .irecvConsumed = pluginIrecvConsumed,
};

__hidden ncclResult_t pluginGetProperties_v6(int dev,
                                             ncclNetProperties_v6_t *props_v6) {
  ncclNetProperties_t props;
  ncclResult_t ret = pluginGetProperties(dev, &props);
  if (ret != ncclSuccess)
    return ret;
  props_v6->name = props.name;
  props_v6->pciPath = props.pciPath;
  props_v6->guid = props.guid;
  props_v6->ptrSupport = props.ptrSupport;
  props_v6->speed = props.speed;
  props_v6->latency = props.latency;
  props_v6->port = props.port;
  props_v6->maxComms = props.maxComms;
  props_v6->maxRecvs = props.maxRecvs;
  return ncclSuccess;
}

__hidden ncclResult_t pluginConnect_v6(int dev, void *handle, void **sendComm) {
  return ncclInternalError;
}
__hidden ncclResult_t pluginAccept_v6(void *listenComm, void **recvComm) {
  return ncclInternalError;
}

const ncclNet_v6_t ncclNetPlugin_v6 = {.name = PLUGIN_NAME,
                                       .init = pluginInit_v9,
                                       .devices = pluginDevices,
                                       .getProperties = pluginGetProperties_v6,
                                       .listen = pluginListen,
                                       .connect = pluginConnect_v6,
                                       .accept = pluginAccept_v6,
                                       .regMr = pluginRegMr_v7,
                                       .regMrDmaBuf = pluginRegMrDmaBuf,
                                       .deregMr = pluginDeregMr,
                                       .isend = pluginIsend_v8,
                                       .irecv = pluginIrecv_v8,
                                       .iflush = pluginIflush,
                                       .test = pluginTest,
                                       .closeSend = pluginCloseSend,
                                       .closeRecv = pluginCloseRecv,
                                       .closeListen = pluginCloseListen};

/* v5 Compat */
const ncclNet_v5_t ncclNetPlugin_v5 = {
    .name = PLUGIN_NAME,
    .init = pluginInit_v9,
    .devices = pluginDevices,
    .getProperties = pluginGetProperties_v6,
    .listen = pluginListen,
    .connect = pluginConnect_v6,
    .accept = pluginAccept_v6,
    .regMr = pluginRegMr_v7,
    .deregMr = pluginDeregMr,
    .isend = pluginIsend_v8,
    .irecv = pluginIrecv_v8,
    .iflush = pluginIflush,
    .test = pluginTest,
    .closeSend = pluginCloseSend,
    .closeRecv = pluginCloseRecv,
    .closeListen = pluginCloseListen,
};

/* v4 Compat */
static ncclResult_t pluginGetProperties_v4(int dev,
                                           ncclNetProperties_v4_t *props_v4) {
  ncclNetProperties_t props;
  ncclResult_t ret = pluginGetProperties(dev, &props);
  if (ret != ncclSuccess)
    return ret;
  props_v4->name = props.name;
  props_v4->pciPath = props.pciPath;
  props_v4->guid = props.guid;
  props_v4->ptrSupport = props.ptrSupport;
  props_v4->speed = props.speed;
  props_v4->port = props.port;
  props_v4->maxComms = props.maxComms;
  return ncclSuccess;
}
static ncclResult_t pluginIsend_v4(void *sendComm, void *data, int size,
                                   void *mhandle, void **request) {
  return pluginIsend_v8(sendComm, data, size, 0, mhandle, request);
}
static ncclResult_t pluginIrecv_v4(void *recvComm, void *data, int size,
                                   void *mhandle, void **request) {
  int tag = 0;
  return pluginIrecv_v8(recvComm, 1, &data, &size, &tag, &mhandle, request);
}
static ncclResult_t pluginIflush_v4(void *recvComm, void *data, int size,
                                    void *mhandle, void **request) {
  return pluginIflush(recvComm, 1, &data, &size, &mhandle, request);
}
static ncclResult_t pluginConnect_v4(int dev, void *handle, void **sendComm) {
  ncclResult_t ret;
  do {
    ncclNetDeviceHandle_v7_t *handle = NULL;
    ret = pluginConnect(dev, NULL, handle, sendComm, &handle);
  } while (ret == ncclSuccess && *sendComm == NULL);
  return ret;
}
static ncclResult_t pluginAccept_v4(void *listenComm, void **recvComm) {
  ncclResult_t ret;
  do {
    ncclNetDeviceHandle_v7_t *handle = NULL;
    ret = pluginAccept(listenComm, recvComm, &handle);
  } while (ret == ncclSuccess && *recvComm == NULL);
  return ret;
}
const ncclNet_v4_t ncclNetPlugin_v4 = {
    .name = PLUGIN_NAME,
    .init = pluginInit_v9,
    .devices = pluginDevices,
    .getProperties = pluginGetProperties_v4,
    .listen = pluginListen,
    .connect = pluginConnect_v4,
    .accept = pluginAccept_v4,
    .regMr = pluginRegMr_v7,
    .deregMr = pluginDeregMr,
    .isend = pluginIsend_v4,
    .irecv = pluginIrecv_v4,
    .iflush = pluginIflush_v4,
    .test = pluginTest,
    .closeSend = pluginCloseSend,
    .closeRecv = pluginCloseRecv,
    .closeListen = pluginCloseListen,
};

/* v3 Compat */
static ncclResult_t pluginFlush(void *recvComm, void *data, int size,
                                void *mhandle) {
  void *req;
  ncclResult_t ret = pluginIflush_v4(recvComm, data, size, mhandle, &req);
  int done = 0;
  while (ret == ncclSuccess && done == 0) {
    ret = pluginTest(req, &done, NULL);
  }
  return ret;
}
static ncclResult_t pluginInit_v3(ncclDebugLogger_t logFunction) {
  max_requests = NCCL_NET_MAX_REQUESTS_V3;
  return pluginInit(logFunction, NULL);
}
#include <string.h>
static ncclResult_t pluginListen_v3(int dev, void *handle, void **listenComm) {
  char pluginHandle[NCCL_NET_HANDLE_MAXSIZE];
  ncclResult_t ret = pluginListen(dev, &pluginHandle, listenComm);
  memcpy(handle, &pluginHandle, NCCL_NET_HANDLE_MAXSIZE_V4);
  return ret;
}
static ncclResult_t pluginConnect_v3(int dev, void *handle, void **sendComm) {
  char pluginHandle[NCCL_NET_HANDLE_MAXSIZE];
  memcpy(&pluginHandle, handle, NCCL_NET_HANDLE_MAXSIZE_V4);
  return pluginConnect_v4(dev, &pluginHandle, sendComm);
}
// const ncclNet_v3_t ncclNetPlugin_v3 = {
//     .name = PLUGIN_NAME,
//     .init = pluginInit_v3,
//     .devices = pluginDevices,
//     .getProperties = pluginGetProperties_v4,
//     .listen = pluginListen_v3,
//     .connect = pluginConnect_v3,
//     .accept = pluginAccept_v4,
//     .regMr = pluginRegMr_v7,
//     .deregMr = pluginDeregMr,
//     .isend = pluginIsend_v4,
//     .irecv = pluginIrecv_v4,
//     .flush = pluginFlush,
//     .test = pluginTest,
//     .closeSend = pluginCloseSend,
//     .closeRecv = pluginCloseRecv,
//     .closeListen = pluginCloseListen,
// };

// /* v2 Compat */
// const ncclNet_v2_t ncclNetPlugin_v2 = {
//     .name = PLUGIN_NAME,
//     .init = pluginInit_v3,
//     .devices = pluginDevices,
//     .pciPath = pluginPciPath,
//     .ptrSupport = pluginPtrSupport,
//     .listen = pluginListen,
//     .connect = pluginConnect_v4,
//     .accept = pluginAccept_v4,
//     .regMr = pluginRegMr_v7,
//     .deregMr = pluginDeregMr,
//     .isend = pluginIsend_v4,
//     .irecv = pluginIrecv_v4,
//     .flush = pluginFlush,
//     .test = pluginTest,
//     .closeSend = pluginCloseSend,
//     .closeRecv = pluginCloseRecv,
//     .closeListen = pluginCloseListen,
// };
